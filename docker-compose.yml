# ============================================
# DOCKER COMPOSE - Application de Gestion de Plats
# ============================================
# Ce fichier orchestre tous les services de l'application
# Chaque service est un conteneur Docker isolé
#
# Les variables d'environnement sont chargées depuis :
# - .env (fichier principal, chargé automatiquement)
# - .env.backend, .env.frontend (fichiers séparés, optionnel)
#
# Pour charger les fichiers séparés, utilisez :
# docker-compose --env-file .env.backend --env-file .env.frontend up
# Ou créez un script shell pour simplifier

services:
  # ============================================
  # SERVICE : Base de données PostgreSQL
  # ============================================
  postgres:
    image: postgres:16-alpine
    container_name: app-cooking-postgres
    restart: unless-stopped
    environment:
      # Ces variables sont chargées depuis .env
      POSTGRES_USER: ${POSTGRES_USER}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
      POSTGRES_DB: ${POSTGRES_DATABASE}
    ports:
      # Port externe:Port interne
      # 5433:5432 signifie que PostgreSQL sera accessible sur localhost:5433
      # depuis votre machine, mais utilise le port 5432 dans le conteneur
      - "${POSTGRES_PORT}:5432"
    volumes:
      # Persistance des données : même si le conteneur est supprimé,
      # les données restent dans postgres_data
      - postgres_data:/var/lib/postgresql/data
      # Script d'initialisation : chargé automatiquement au premier démarrage
      - ./docker/postgres/init.sql:/docker-entrypoint-initdb.d/init.sql:ro
    networks:
      - app-network
    healthcheck:
      # Vérifie que PostgreSQL est prêt avant de démarrer les autres services
      test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER} -d ${POSTGRES_DATABASE}"]
      interval: 10s
      timeout: 5s
      retries: 5

  # ============================================
  # SERVICE : Backend Nest.js (API)
  # ============================================
  backend:
    build:
      # Chemin vers le Dockerfile du backend Nest.js
      context: ./backend
      dockerfile: ../docker/backend/Dockerfile
    container_name: app-cooking-backend
    restart: unless-stopped
    environment:
      # Variables d'environnement chargées depuis .env.backend
      NODE_ENV: ${NODE_ENV}
      DATABASE_URL: ${DATABASE_URL}
      PORT: 3000
    ports:
      # Nest.js sera accessible sur localhost:3000
      - "${BACKEND_PORT}:3000"
    volumes:
      # Montage du code source pour le développement
      # Cela permet de voir les changements sans reconstruire l'image
      - ./backend:/app
      - /app/node_modules
      # Prisma nécessite le schéma
      - ./backend/prisma:/app/prisma
    depends_on:
      postgres:
        condition: service_healthy
    networks:
      - app-network
    # Commande pour démarrer Nest.js en mode développement
    command: npm run start:dev

  # ============================================
  # SERVICE : Frontend Symfony (Interface utilisateur) - PHP-FPM
  # ============================================
  frontend:
    build:
      context: ./frontend
      dockerfile: ../docker/frontend/Dockerfile
    container_name: app-cooking-frontend
    restart: unless-stopped
    environment:
      # Variables d'environnement chargées depuis .env.frontend
      APP_ENV: ${APP_ENV}
      APP_SECRET: ${APP_SECRET}
      DATABASE_URL: ${DATABASE_URL}
    # PHP-FPM écoute sur le port 9000 (interne, pas exposé)
    # Il est accessible uniquement via Nginx
    volumes:
      # Montage du code source pour le développement
      - ./frontend:/var/www/html
      - /var/www/html/var
      - /var/www/html/vendor
    depends_on:
      backend:
        condition: service_started
      postgres:
        condition: service_healthy
    networks:
      - app-network
    # PHP-FPM démarre automatiquement via CMD dans le Dockerfile

  # ============================================
  # SERVICE : Nginx (Reverse proxy pour Symfony)
  # ============================================
  nginx:
    image: nginx:alpine
    container_name: app-cooking-nginx
    restart: unless-stopped
    ports:
      # Nginx sera accessible sur localhost:8000
      - "${FRONTEND_PORT}:80"
    volumes:
      # Configuration Nginx
      - ./docker/frontend/nginx.conf:/etc/nginx/conf.d/default.conf:ro
      # Code source Symfony (lecture seule pour Nginx)
      - ./frontend:/var/www/html:ro
    depends_on:
      - frontend
    networks:
      - app-network

  # ============================================
  # SERVICE : pgAdmin (Interface de gestion PostgreSQL)
  # ============================================
  pgadmin:
    image: dpage/pgadmin4:latest
    container_name: app-cooking-pgadmin
    restart: unless-stopped
    environment:
      # Configuration pgAdmin
      PGADMIN_DEFAULT_EMAIL: ${PGADMIN_EMAIL:-admin@admin.com}
      PGADMIN_DEFAULT_PASSWORD: ${PGADMIN_PASSWORD:-admin}
      PGADMIN_CONFIG_SERVER_MODE: 'False'
      PGADMIN_CONFIG_MASTER_PASSWORD_REQUIRED: 'False'
    ports:
      # pgAdmin sera accessible sur localhost:8080
      - "${PGADMIN_PORT:-8080}:80"
    volumes:
      # Persistance des configurations pgAdmin
      - pgadmin_data:/var/lib/pgadmin
    depends_on:
      postgres:
        condition: service_healthy
    networks:
      - app-network

# ============================================
# VOLUMES
# ============================================
# Les volumes persistent les données même après
# la suppression des conteneurs
volumes:
  postgres_data:
    driver: local
  pgadmin_data:
    driver: local

# ============================================
# RÉSEAUX
# ============================================
# Tous les services peuvent communiquer entre eux
# via le réseau app-network
networks:
  app-network:
    driver: bridge

